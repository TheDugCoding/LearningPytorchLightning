Questions

1.  numpy array vs list, and why is python so slow with loops
2.  how to declare an array and the type of the elements
3.  explain: np.zeros(), np.ones(), np.full(), np.arange(),
    np.linspace(), np.random.random(), np.random.normal(),
    np.empty()
4.  what is np.random.seed()?
5.  explain .ndim, .shape, .size
6.  how can I access the elements in an array
7.  slicing explain, x[:5], x[4:7], x[::2], x[::-1], x2[:2, :3]
8.  difference between copies and views
9.  reshaping of arrays
10. how can we concatenate two arrays?
11. what are vectorized operations, ufuncs, and broadcasting
12. what are aggregator functions?
13. explain np.sum, np.prod, np.mean, np.std, np.min, np.max
14. the 3 rules of broadcasting
15. what is the purpose of where?

Answers

1.  numpy arrays are more efficient, whereas list are more flexible. arrays contain only one type of data
    Instead lists contain a lot of references to different objects
2.  np.array([1,2,3,4,5], dtype='float32')
3.  np.zeros(10, dtype) create an array of zeroes
    np.ones((3,5), dtype) array filled with ones
    np.full((3,4), value) array filled with values
    np.arange(start, end, step) array with numbers from start to end
    np.linspace(0,1,5) create an array with 5 elements equally distanced between
    0 and 1
    np.random.random((3,3)) random values between 0 and 1
    np.random.normal(0, 1, (3,3)) normally distributed values
    np.empty(3) array with no values, it is not actually empty
    it contains values from memory
4.  it is used for reproducibility purposes, set a random seed for the generation
    of values
5.  those are attributes .ndim is the number of dimensions, .shape is the
    shape of the dimensions, .size total size of array
6.  like a list x[0, 4, 1]
7.  x[:5], start from element 5
    x[4:7] take elements between 4 and 7
    x[::2] take alternative elements
    x[::-1] reverse the order of the elements
    x2[:2, :3] take from the second row onwards and from the third
    columns onward
8.  copy: create a copy of an array, changes to this copy are not reported
    in the original one
    view: referencing the original or a sub array of the original array
    changes to the view modify the original array
9.  reshaping means that we can change the dimensions of an array
    by using .reshape(), the size of the initial array must be the same of
    the final array
10. np.concatenate([arr1, arr2]) or np.vstack, and np.hstack
11. vectorized operations are statyc operations that runs below
    the underlying layer of numpy, making the loops more faster.
    vectorized operations are implemented through ufuncs, we have unary and binary
    ufuncs, for ufuncs between arrays it is possible to use the normal
    operators
    broadcasting is the process of aligning arrays with different shapes and
    do operations on them
12. aggregator functions are functions that operate on all the elements of
    an array
13. np.sum: sum of the array's elements
    np.prod: product of the elements
    np.mean: mean of the elements
    np.std: standard deviation
    np.min: minimum value
    np.max: maximum value
14. • Rule 1: If the two arrays differ in their number of dimensions,
    the shape of the one with fewer dimensions is padded with ones on
    its leading (left) side.
    • Rule 2: If the shape of the two arrays does not match in any dimension,
     the array with shape equal to 1 in that dimension is stretched to
     match the other shape.
    • Rule 3: If in any dimension the sizes disagree and neither is equal to 1,
     an error is raised.
15. we use where when we want specific elements from an array

